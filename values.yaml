## Global Docker image parameters
## Please, note that this will override the image parameters, including dependencies, configured to use the global value
## Current available global Docker image parameters: imageRegistry and imagePullSecrets
##
global:
  imageRegistry: 
  imagePullSecrets:
    - nexus-pull
    - registry
  storageClass: local-path

  coordinating:
    name: coordinator

image:
  registry: 
  repository: public/ocp-3rd/bitnami/elasticsearch
  tag: 
  pullPolicy: IfNotPresent
  debug: false

sysctlImage:
  enabled: false

volumePermissions:
  enabled: false

clusterDomain: cluster.local

name: 
nameOverride:
fullnameOverride:

## Comma, semi-colon or space separated list of plugins to install at initialization
## ref: https://github.com/bitnami/bitnami-docker-elasticsearch#environment-variables
##
# plugins:

## File System snapshot repository path
## ref: https://github.com/bitnami/bitnami-docker-elasticsearch#environment-variables
##
# snapshotRepoPath:

## Override elasticsearch configuration
##
# config:

## Append extra configuration to the elasticsearch node configuration
## Use this instead of `config` to add more configuration
## See below example:
## extraConfig:
##   node:
##     store:
##       allow_mmap: false
## ref: https://www.elastic.co/guide/en/elasticsearch/reference/current/settings.html
##
extraConfig:
  xpack.graph.enabled: false
  xpack.ml.enabled: false
  xpack.security.enabled: true
  xpack.security.transport.ssl.enabled: true
  xpack.security.transport.ssl.verification_mode: certificate
  xpack.security.transport.ssl.keystore.path: /opt/bitnami/elasticsearch/config/certs/keystore.p12
  xpack.security.transport.ssl.keystore.password: changeit
  xpack.security.transport.ssl.truststore.path: /opt/bitnami/elasticsearch/config/trustedca/truststore.jks
  xpack.security.transport.ssl.truststore.password: changeit
  xpack.security.http.ssl.enabled: true
  xpack.security.http.ssl.keystore.path: /opt/bitnami/elasticsearch/config/certs/keystore.p12
  xpack.security.http.ssl.keystore.password: changeit
  xpack.security.http.ssl.truststore.path: /opt/bitnami/elasticsearch/config/trustedca/truststore.jks
  xpack.security.http.ssl.truststore.password: changeit


## extraVolumes and extraVolumeMounts allows you to mount other volumes
## Example Use Case: mount ssl certificates when elasticsearch has tls enabled
extraVolumes:
   - name: elastic-certificates
     secret:
       defaultMode: 0755
       secretName: elastic-cert-tls-bundle
   - name: root-ca
     secret:
       defaultMode: 0755
       secretName: ocp-intern-root-ca
   - name: add-ons
     emptyDir: { }

extraVolumeMounts:
   - name: elastic-certificates
     mountPath: /opt/bitnami/elasticsearch/config/certs
     readOnly: true
   - name: root-ca
     mountPath: /opt/bitnami/elasticsearch/config/trustedca
     readOnly: true
   - name: add-ons
     mountPath: /tmp/add-ons


initScripts:
  auth-setup.sh: |
    #!/usr/bin/env bash
    set -euo pipefail
    elasticsearch-keystore create
    if [ ! -z ${ELASTIC_PASSWORD+x} ]; then 
      echo 'Adding env $ELASTIC_PASSWORD to keystore as key bootstrap.password'
      echo "$ELASTIC_PASSWORD" | elasticsearch-keystore add -x bootstrap.password
    fi

## ConfigMap with scripts to be run at first boot
## Note: This will override initScripts
##
initScriptsCM:

## Secret with init scripts to execute (for sensitive data)
##
initScriptsSecret:

## An array to add extra env vars
## For example:
## extraEnvVars:
##  - name: MY_ENV_VAR
##    value: env_var_value
##
extraEnvVars:
 - name: ELASTIC_PASSWORD
   valueFrom:
     secretKeyRef:
       name: elastic-secret
       key: password
 - name: ELASTIC_USERNAME
   valueFrom:
     secretKeyRef:
       name: elastic-secret
       key: username

## Name of a ConfigMap containing extra env vars
##
extraEnvVarsConfigMap:

## Name of a Secret containing extra env vars
##
extraEnvVarsSecret:

## Elasticsearch master-eligible node parameters
##
master:
  name: master
  fullnameOverride: master
  replicas: 3
  updateStrategy:
    type: RollingUpdate
  hostAliases: []

  heapSize:
  podAnnotations: {}
  podLabels: {
    es.node.type: "stateful"
  }

  securityContext:
    enabled: true
    fsGroup: 1001
    runAsUser: 1001

  affinity:         
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: elasticsearch
            operator: In
            values:
            - "true"
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: es.node.type
            operator: In
            values:
            - stateful
        topologyKey: kubernetes.io/hostname

  nodeSelector: {
    elasticsearch: "true"
  }

  tolerations:
    - key: "stateful"
      operator: "Equal"
      effect: "NoSchedule"
      value: "true"

  resources:
    limits:
       cpu: 4000m
       memory: 
    requests:
      cpu: 200m
      memory: 

  startupProbe:
    enabled: false
  livenessProbe:
    enabled: false
  readinessProbe:
    enabled: false
    
  customLivenessProbe:
    initialDelaySeconds: 240
    periodSeconds: 10
    timeoutSeconds: 10
    successThreshold: 1
    failureThreshold: 10
    exec:
      command:
        - sh
        - -c
        - |
          #!/usr/bin/env bash -e
          probe="https://${ELASTIC_USERNAME}:${ELASTIC_PASSWORD}@0.0.0.0:9200"
          rep=$(curl -f -v -k $probe)
          status=$?
          exit $status

  persistence:
    enabled: true
    storageClass: "local-path"
    annotations: {}
    accessModes:
      - ReadWriteOnce
    size: 8Gi

  service:
    type: ClusterIP
    port: 9300
    annotations: {}

  serviceAccount:
    create: false
 
  autoscaling:
    enabled: false

  initContainers: 
  - name: copy-plugins
    image: registry-ocp.idst.ibaintern.de:5050/opdt/elasticsearch-plugins
    command: ["/bin/sh", "-c", "cp -r /tmp/plugins/* /tmp/add-ons"]
    volumeMounts:
    - name: add-ons
      mountPath: /tmp/add-ons

## Elasticsearch coordinating-only node parameters
##
coordinating:
  replicas: 2
  hostAliases: []
  fullnameOverride: coordinator
  updateStrategy:
    type: RollingUpdate
  heapSize:
  podAnnotations: {}
  podLabels: {
    es.node.type: "stateless"
  }
  securityContext:
    enabled: true
    fsGroup: 1001
    runAsUser: 1001
  affinity:         
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: elasticsearch
            operator: In
            values:
            - "true"

  nodeSelector: {
    elasticsearch: "true"
  }

  tolerations:
    - key: "stateful"
      operator: "Equal"
      effect: "NoSchedule"
      value: "true"

  resources:
    limits:
       cpu: 4000m
       memory: 
    requests:
      cpu: 200m
      memory: 

  startupProbe:
    enabled: false
  livenessProbe:
    enabled: false
  readinessProbe:
    enabled: false

  customLivenessProbe:
    initialDelaySeconds: 240
    periodSeconds: 10
    timeoutSeconds: 10
    successThreshold: 1
    failureThreshold: 10
    exec:
      command:
        - sh
        - -c
        - |
          #!/usr/bin/env bash -e
          probe="https://${ELASTIC_USERNAME}:${ELASTIC_PASSWORD}@0.0.0.0:9200"
          rep=$(curl -f -v -k $probe)
          status=$?
          exit $status

  service:
    type: ClusterIP
    port: 9200
    annotations: {}

  serviceAccount:
    create: false

  autoscaling:
    enabled: false

  initContainers: 
  - name: copy-plugins
    image: registry-ocp.idst.ibaintern.de:5050/opdt/elasticsearch-plugins
    command: ["/bin/sh", "-c", "cp -r /tmp/plugins/* /tmp/add-ons"]
    volumeMounts:
    - name: add-ons
      mountPath: /tmp/add-ons

## Elasticsearch data node parameters
##
data:
  name: data
  fullnameOverride: data
  replicas: 0
  hostAliases: []
  updateStrategy:
    type: RollingUpdate
  heapSize:
  podAnnotations: {}
  podLabels: {
    es.node.type: "stateful"
  }
  securityContext:
    enabled: true
    fsGroup: 1001
    runAsUser: 1001

  affinity:         
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: elasticsearch
            operator: In
            values:
            - "true"
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: es.node.type
            operator: In
            values:
            - stateful
        topologyKey: kubernetes.io/hostname

  nodeSelector: {
    elasticsearch: "true"
  }

  tolerations:
    - key: "stateful"
      operator: "Equal"
      effect: "NoSchedule"
      value: "true"

  resources:
    limits:
       cpu: 4000m
       memory: 
    requests:
      cpu: 200m
      memory: 

  startupProbe:
    enabled: false
  livenessProbe:
    enabled: false
  readinessProbe:
    enabled: false

  customLivenessProbe:
    initialDelaySeconds: 240
    periodSeconds: 10
    timeoutSeconds: 10
    successThreshold: 1
    failureThreshold: 10
    exec:
      command:
        - sh
        - -c
        - |
          #!/usr/bin/env bash -e
          probe="https://${ELASTIC_USERNAME}:${ELASTIC_PASSWORD}@0.0.0.0:9200"
          rep=$(curl -f -v -k $probe)
          status=$?
          exit $status  

  persistence:
    enabled: true
    annotations: {}
    accessModes:
      - ReadWriteOnce
    size: 8Gi

  serviceAccount:
    create: false

  autoscaling:
    enabled: false

  initContainers: 
  - name: copy-plugins
    image: registry-ocp.idst.ibaintern.de:5050/opdt/elasticsearch-plugins
    command: ["/bin/sh", "-c", "cp -r /tmp/plugins/* /tmp/add-ons"]
    volumeMounts:
    - name: add-ons
      mountPath: /tmp/add-ons

## Elasticsearch ingest node parameters
##
ingest:
  enabled: true
  name: ingest
  fullnameOverride: ingest
  replicas: 2
  heapSize:
  podAnnotations: {}
  hostAliases: []
  podLabels: {
    es.node.type: "stateless"
  }

  securityContext:
    enabled: true
    fsGroup: 1001
    runAsUser: 1001
  
  affinity:         
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: elasticsearch
            operator: In
            values:
            - "true"

  nodeSelector: {
    elasticsearch: "true"
  }

  tolerations:
    - key: "stateful"
      operator: "Equal"
      effect: "NoSchedule"
      value: "true"

  resources:
    limits:
       cpu: 4000m
       memory: 
    requests:
      cpu: 200m
      memory: 

  startupProbe:
    enabled: false
  livenessProbe:
    enabled: false
  readinessProbe:
    enabled: false

  customLivenessProbe:
    initialDelaySeconds: 240
    periodSeconds: 10
    timeoutSeconds: 10
    successThreshold: 1
    failureThreshold: 10
    exec:
      command:
        - sh
        - -c
        - |
          #!/usr/bin/env bash -e
          probe="https://${ELASTIC_USERNAME}:${ELASTIC_PASSWORD}@0.0.0.0:9200"
          rep=$(curl -f -v -k $probe)
          status=$?
          exit $status


  service:
    type: ClusterIP
    port: 9300
    annotations: {}

  initContainers: 
  - name: copy-plugins
    image: registry-ocp.idst.ibaintern.de:5050/opdt/elasticsearch-plugins
    command: ["/bin/sh", "-c", "cp -r /tmp/plugins/* /tmp/add-ons"]
    volumeMounts:
    - name: add-ons
      mountPath: /tmp/add-ons

## Elasticsearch curator parameters
##
curator:
  enabled: false
 

## Elasticsearch Prometheus exporter configuration
## ref: https://hub.docker.com/r/bitnami/elasticsearch-exporter/tags/
##
metrics:
  enabled: false
  name: metrics
  image:
    registry: docker.io
    repository: bitnami/elasticsearch-exporter
    tag: 1.2.0-debian-10-r5
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ##
    # pullSecrets:
    #   - myRegistryKeySecretName

  ## Extra arguments for the exporter
  ## ref: https://github.com/justwatchcom/elasticsearch_exporter
  ## e.g
  ## extraArgs:
  ##   - --es.snapshots
  ##   - --es.indices
  ##
  extraArgs: []

  ## Deployment pod host aliases
  ## https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/
  ##
  hostAliases: []

  ## Use an alternate scheduler, e.g. "stork".
  ## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
  ##
  # schedulerName:

  ## Elasticsearch Prometheus exporter service type
  ##
  service:
    type: ClusterIP
    ## Provide any additional annotations which may be required. This can be used to
    ## set the LoadBalancer service type to internal only.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
    ##
    annotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9114"

  ## Pod affinity preset
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  ## Allowed values: soft, hard
  ##
  podAffinityPreset: ""

  ## Pod anti-affinity preset
  ## Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  ## Allowed values: soft, hard
  ##
  podAntiAffinityPreset: ""

  ## Node affinity preset
  ## Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity
  ## Allowed values: soft, hard
  ##
  nodeAffinityPreset:
    ## Node affinity type
    ## Allowed values: soft, hard
    ##
    type: ""
    ## Node label key to match
    ## E.g.
    ## key: "kubernetes.io/e2e-az-name"
    ##
    key: ""
    ## Node label values to match
    ## E.g.
    ## values:
    ##   - e2e-az1
    ##   - e2e-az2
    ##
    values: []

  ## Affinity for pod assignment
  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ## Note: podAffinityPreset, podAntiAffinityPreset, and  nodeAffinityPreset will be ignored when it's set
  ##
  affinity: {}

  ## Node labels for pod assignment
  ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}

  ## Tolerations for pod assignment
  ## Ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []

  ## Elasticsearch Prometheus exporter resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits: {}
    #   cpu: 100m
    #   memory: 128Mi
    requests: {}
    #   cpu: 100m
    #   memory: 128Mi
  ## Metrics exporter pod Annotation and Labels
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "9114"

  ## Extra labels to add to Pod
  ##
  podLabels: {}

  ## Prometheus Operator ServiceMonitor configuration
  ##
  serviceMonitor:
    enabled: false
    ## Namespace in which Prometheus is running
    ##
    # namespace: monitoring

    ## Interval at which metrics should be scraped.
    ## ref: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
    ##
    # interval: 10s

    ## Timeout after which the scrape is ended
    ## ref: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
    ##
    # scrapeTimeout: 10s

    ## ServiceMonitor selector labels
    ## ref: https://github.com/bitnami/charts/tree/master/bitnami/prometheus-operator#prometheus-configuration
    ##
    # selector:
    #   prometheus: my-prometheus

## Bundled Kibana parameters
##
kibana:
  elasticsearch:
    hosts:
      - '{{ include "elasticsearch.coordinating.fullname" . }}'
    port: 9200
